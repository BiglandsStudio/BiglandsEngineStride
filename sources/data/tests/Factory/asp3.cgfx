// ï¿½ÏŠï¿½ï¿½sï¿½ï¿½
// ï¿½Eï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½Íƒrï¿½ï¿½ï¿½[ï¿½|ï¿½[ï¿½gï¿½ÌƒJï¿½ï¿½ï¿½ï¿½ï¿½Ê’uï¿½Æƒï¿½ï¿½fï¿½ï¿½ï¿½Ì”zï¿½uï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ü‚ï¿½ï¿½B
float4x4 g_mtxWorld			: WORLD;
float4x4 g_mtxView			: VIEW;
float4x4 g_mtxProjection	: PROJECTION;
float4x4 g_mtxWorldViewProj : WORLDVIEWPROJECTION;
float4x4 g_mtxWorldView		: WORLDVIEW;
float4x4 g_imtxView			: VIEWI;

// ï¿½ï¿½ï¿½Cï¿½gï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^
// ï¿½Eï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½ÍƒVï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½É‚ï¿½ï¿½éƒ‰ï¿½Cï¿½gï¿½Ìï¿½ñ‚ª”ï¿½ï¿½fï¿½ï¿½ï¿½Ü‚ï¿½ï¿½B
// ï¿½Eï¿½pï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½^ï¿½ï¿½Viewï¿½ï¿½ï¿½Wï¿½nï¿½Åwï¿½è‚³ï¿½ï¿½Ü‚ï¿½ï¿½B
float3 g_vtLightDir : VIEWDIRECTION
<  
	string UIName = "Parallel Light"; 
	string Object = "TargetLight";
	int refID = 0;
> = {0.477, -0.577, -0.677};

float4 g_colorLight : LIGHTCOLOR
<
	int LightRef = 0;
> = float4(1.0f, 1.0f, 1.0f, 1.0f);

// ï¿½ï¿½ï¿½Cï¿½eï¿½Bï¿½ï¿½ï¿½Oï¿½Ì—Lï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½
bool g_enablesLighting
<
	string UIName = "Lighting";
> = true;

// ï¿½gï¿½Uï¿½ï¿½ï¿½ËƒJï¿½ï¿½ï¿½[ï¿½Ìƒ\ï¿½[ï¿½Xï¿½Iï¿½ï¿½
int g_diffuseColorSelect
<
	string UIName = "Diffuse Color Select";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 2;
	int UIStep = 1;
> = 0;

// ï¿½gï¿½Uï¿½ï¿½ï¿½Ë‚ÌŒÅ’ï¿½Jï¿½ï¿½ï¿½[
float4 g_diffuseColor
<
	string UIName = "Material Color";
> = float4( 0.80f, 0.80f, 0.80f, 1.0f );

// ï¿½ï¿½ï¿½ï¿½ï¿½x
float g_transparency
<
	string UIName = "Transparency";
	float UIMin = 0.0f;
	float UIMax = 1.0f;
	float UIStep = 0.001f;
> = 0.0f;

// ï¿½ï¿½ï¿½È”ï¿½ï¿½ï¿½
float3 g_emissionColor
<
	string UIName = "Emission";
> = float3(0.00f, 0.00f, 0.00f);

// ï¿½ï¿½ï¿½Cï¿½eï¿½Bï¿½ï¿½ï¿½Oï¿½É‚ï¿½ï¿½ï¿½ï¿½ï¿½gï¿½Uï¿½ï¿½ï¿½Ë‹Pï¿½xï¿½ÌƒXï¿½Pï¿½[ï¿½ï¿½
float g_diffuseAttenuation
<
	string UIName = "Luminance";
	float UIMin = 0.0f;
	float UIMax = 2.0f;
	float UIStep = 0.01f;
> = 1.0f;

// ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½Ìİ’ï¿½
bool g_enablesSpecular
<
	string UIName = "Specular";
> = false;

int g_specularColorSelector
<
	string UIName = "Specular Color Select";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 3;
	int UIStep = 1;
> = 0;

float3 g_colorSpecular
<
	string UIName = "Specular Color";
> = float3( 0.80f, 0.80f, 0.80f );

float g_SpecularPower
<
	string UIName = "Specular Power";
	string UIType = "FloatSpinner";
	float UIMin = 0.01f;
	float UIMax = 256.0f;
> = 32.0f;

// ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[
bool g_enablesRimSpecular
<
	string UIName = "Rim Specular";
> = false;

float3 g_colorRimSpecular
<
	string UIName = "Rim Specular Color";
> = float3( 0.80f, 0.80f, 0.80f );

float g_rimSpecularPower
<
	string UIName = "Rim Specular power";
	string UIType = "FloatSpinner";
	float UIMin = 0.01f;
	float UIMax = 256.0f;
> = 5.0f;

float g_rimSpecularSelfLuminous
<
	string UIName = "Rim Specular Luminous";
	string UIType = "FloatSpinner";
	float UIMin = 0.0f;
	float UIMax = 2.0f;
> = 1.0f;


// ï¿½xï¿½[ï¿½Xï¿½Jï¿½ï¿½ï¿½[ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
// ï¿½Eï¿½rï¿½bï¿½gï¿½}ï¿½bï¿½v
// ï¿½Eï¿½}ï¿½bï¿½vï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½
bool g_enablesBaseColorTex
<
	string UIName = "Base Texture";
> = false;


texture g_texBaseColor : DiffuseMap
<
	string UIName = "Base Texture";
	int Texcoord = 0;
	int MapChannel = 1;
>;

sampler2D g_texsmpBaseColor = sampler_state
{
	Texture = <g_texBaseColor>;
	minFilter = Linear;
	magFilter = Linear;
};

int g_blendBaseColorTexture
<
	string UIName = "Base Texture Blend";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 6;
	int UIStep = 1;
> = 0;

int g_baseColorTexTransform
<
	string UIName = "Base Texture Transform";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 3;
	int UIStep = 1;
> = 0;

// ï¿½â•ï¿½Jï¿½ï¿½ï¿½[ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
// ï¿½Eï¿½rï¿½bï¿½gï¿½}ï¿½bï¿½v
// ï¿½Eï¿½}ï¿½bï¿½vï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½
bool g_enablesUtilColorTex
<
	string UIName = "Util Texture";
> = false;

texture g_texUtilColor : DiffuseMap
<
	string UIName = "Texture";
	int Texcoord = 1;
	int MapChannel = 1;
>;

sampler2D g_texsmpUtilColor = sampler_state
{
	Texture = <g_texUtilColor>;
	minFilter = Linear;
	magFilter = Linear;
};

int g_blendUtilColorTexture
<
	string UIName = "Util Texture Blend";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 8;
	int UIStep = 1;
> = 0;

int g_utilColorTexTransform
<
	string UIName = "Util Texture Transform";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 3;
	int UIStep = 1;
> = 0;

// ï¿½Oï¿½ï¿½ï¿½Xï¿½}ï¿½bï¿½v
bool g_enablesGlossMap
<
	string UIName = "Gloss Map";
> = false;

int g_indexGlossSrc
<
	string UIName = "Gloss Map Source";
	int UIMin = 0;
	int UIMax = 2;
	int UIStep = 1;
> = 0;

// ï¿½@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
// ï¿½Eï¿½rï¿½bï¿½gï¿½}ï¿½bï¿½v
// ï¿½Eï¿½}ï¿½bï¿½vï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½
// ï¿½Eï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½
bool g_enablesNormalMap
<
	string UIName = "Normal Map";
> = false;

texture g_texNormalMap : NormalMap
<
	string UIName = "NormalMap Texture";
	int Texcoord = 2;
	int MapChannel = 1;
>;

sampler2D g_texsmpNormalMap = sampler_state
{
	Texture = <g_texNormalMap>;
	minFilter = Linear;
	magFilter = Linear;
};

// ï¿½@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½ÌŠï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Ì‘Iï¿½ï¿½(ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½n/ï¿½Úï¿½ï¿½ï¿½ï¿½Wï¿½n)
int g_normalMapType
<
	string UIName = "Normal Map Type";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 1;
	int UIStep = 1;
> = 0;

int g_normalMapTexTransform
<
	string UIName = "NormalMap Transform";
	string UIType = "Spinner";
	int UIMin = 0;
	int UIMax = 3;
	int UIStep = 1;
> = 0;

// ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½Å‚Ì–@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½ï¿½RGBï¿½ÌŠï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½B
int g_normalMapAxisR
<
	string UIName = "Base Axis of R";
	string UIWidget = "Slider";
	int UIMin = 0;
	int UIMax = 5;
	int UIStep = 1;
> = 0;

int g_normalMapAxisG
<
	string UIName = "Base Axis of G";
	string UIWidget = "Slider";
	int UIMin = 0;
	int UIMax = 5;
	int UIStep = 1;
> = 2;

int g_normalMapAxisB
<
	string UIName = "Base Axis of B";
	string UIWidget = "Slider";
	int UIMin = 0;
	int UIMax = 5;
	int UIStep = 1;
> = 4;

const float3 g_vtBaseAxis[6] =
{
	{  1, 0, 0, },		// +X
	{ -1, 0, 0, },		// -X
	{ 0,  1, 0, },		// +Y
	{ 0, -1, 0, },		// -Y
	{ 0, 0,  1, },		// +Z
	{ 0, 0, -1, },		// -Z
};

// ï¿½Úï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½Å‚Ì–@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½ÌARï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½B
bool g_swapTangentAndBinormal
<
	string UIName = "Swap Tgt and Bnml.";
> = false;

// ï¿½Úï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½Tangentï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ÌŒï¿½ï¿½ï¿½ï¿½ğ”½“]ï¿½ï¿½ï¿½ï¿½B
bool g_flipTangent
<
	string UIName = "Flip Tangent";
> = false;

// ï¿½Úï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½Binormalï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ÌŒï¿½ï¿½ï¿½ï¿½ğ”½“]ï¿½ï¿½ï¿½ï¿½B
bool g_flipBinormal
<
	string UIName = "Flip Binormal";
> = false;

// ï¿½@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½Ìƒfï¿½oï¿½bï¿½O
bool g_debugShowNormalDir
<
	string UIName = "Output Normal To Color";
> = false;

// ï¿½Â‹ï¿½ï¿½}ï¿½bï¿½vï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½
// ï¿½Eï¿½rï¿½bï¿½gï¿½}ï¿½bï¿½v
// ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[
// ï¿½Eï¿½tï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½
bool g_enablesEnvironmentMap
<
	string UIName = "Environment Map";
> = false;

texture g_texCubeEnvironmentMap : EnvironmentMap
<
	string UIName = "Cube Map Texture";
	string Type = "Cube";
>;

samplerCUBE	g_texsmpCubeEnvironmentMap = sampler_state
{
	Texture = <g_texCubeEnvironmentMap>;
	minFilter = Linear;
	magFilter = Linear;
};

texture g_texSphereEnvironmentMap
<
	string UIName = "Sphere Map Texture";
>;

sampler2D	g_texsmpSphericalEnvironmentMap = sampler_state
{
	Texture = <g_texSphereEnvironmentMap>;
	MinFilter = Linear;
	MagFilter = Linear;
};

int g_environmentMapType
<
	string UIName = "Env Map Type";
	int UIMin = 0;
	int UIMax = 2;
	int UIStep = 1;
> = 0;

float4 g_colorEnvironmentMapModulate
<
	string UIName = "Env Map Color";
> = float4( 1.00f, 1.00f, 1.00f, 1.0f );

bool g_enablesFresnelTerm
<
	string UIName = "Use Fresnel";
> = false;

float g_fresnelR0
<
	string UIName = "Fresnel Front";
	float UIMin = 0.0f;
	float UIMax = 1.0f;
	float UIStep = 0.01f;
> = 0.2f;

float g_fresnelR1
<
	string UIName = "Fresnel Side";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
> = 0.8f;

// ï¿½pï¿½ï¿½ï¿½ï¿½ï¿½bï¿½Nï¿½Xï¿½}ï¿½bï¿½v
bool g_enablesParallaxMap
<
	string UIName = "Parallax Map";
> = false;

int g_parallaxMapSource
<
	string UIName = "Parallax Map Source";
	int UIMin = 0;
	int UIMax = 2;
	int UIStep = 1;
> = 0;

float g_parallaxMapBiglandsEngine
<
	string UIName = "Parallax Map BiglandsEngine";
> = 0.03f;

// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½Pï¿½ÌˆÚ“ï¿½ï¿½ï¿½ï¿½ï¿½
float2 g_texcoordTransformOffset1
<
	string UIName = "TexTransform1 Offset";
> = float2( 0.0f, 0.0f );

// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½Pï¿½Ìkï¿½Úï¿½ï¿½ï¿½
float2 g_texcoordTransformRepeat1
<
	string UIName = "TexTransform1 Repeat";
> = float2( 1.0f, 1.0f );

// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½Qï¿½ÌˆÚ“ï¿½ï¿½ï¿½ï¿½ï¿½
float2 g_texcoordTransformOffset2
<
	string UIName = "TexTransform2 Offset";
> = float2( 0.0f, 0.0f );

// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½Qï¿½Ìkï¿½Úï¿½ï¿½ï¿½
float2 g_texcoordTransformRepeat2
<
	string UIName = "TexTransform2 Repeat";
> = float2( 1.0f, 1.0f );

// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½Rï¿½ÌˆÚ“ï¿½ï¿½ï¿½ï¿½ï¿½
float2 g_texcoordTransformOffset3
<
	string UIName = "TexTransform3 Offset";
> = float2( 0.0f, 0.0f );

// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ÏŠï¿½ï¿½Rï¿½Ìkï¿½Úï¿½ï¿½ï¿½
float2 g_texcoordTransformRepeat3
<
	string UIName = "TexTransform3 Repeat";
> = float2( 1.0f, 1.0f );


// ï¿½tï¿½Hï¿½Oï¿½Ì‰eï¿½ï¿½
bool g_enablesFog
<
	string UIName = "Fog";
> = true;

// ï¿½Â‹ï¿½ï¿½ï¿½(ï¿½Â‹ï¿½ï¿½Oï¿½ï¿½ï¿½[ï¿½oï¿½ï¿½)
float3 g_ambientLightColor
<
	string UIName = "Ambient Light Color";
> = float3(0.3, 0.3, 0.3);

// ï¿½tï¿½Hï¿½O(ï¿½Â‹ï¿½ï¿½Oï¿½ï¿½ï¿½[ï¿½oï¿½ï¿½)
// ï¿½Eï¿½ï¿½ï¿½
// ï¿½Eï¿½tï¿½Hï¿½Oï¿½Jï¿½ï¿½ï¿½[
// ï¿½Eï¿½ï¿½ï¿½jï¿½Aï¿½tï¿½Hï¿½Oï¿½ÌŠJï¿½n/ï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
// ï¿½Eï¿½wï¿½ï¿½ï¿½tï¿½Hï¿½Oï¿½Ì”Zï¿½xï¿½Wï¿½ï¿½
int g_fogDensityType
<
	string UIName = "Fog Density Type";
	int UIMin = 0;
	int UIMax = 3;
	int UIStep = 1;
> = 0;

float4 g_fogColor
<
	string UIName = "Fog Color";
> = float4( 0.80f, 0.80f, 0.80f, 1.0f );

float g_fogStart
<
	string UIName = "Fog Start";
	float UIMin = 0.0;
	float UIMax = 10000.0;
	float UIStep = 1.0;
> = 1.0;

float g_fogEnd
<
	string UIName = "Fog End";
	float UIMin = 0.0;
	float UIMax = 10000.0;
	float UIStep = 1.0;
> = 100.0;

float g_fogDensity
<
	string UIName = "Fog Density(1/1000)";
	float UIMin = 0.0;
	float UIMax = 100.0;
	float UIStep = 0.01;
> = 1.0;

struct VSOutput
{
	float4 vtPosition			: POSITION;
   	float3 vtViewDirection		: TEXCOORD0;
   	float2 uv0					: TEXCOORD1;
   	float2 uv1					: TEXCOORD2;
   	float2 uv2					: TEXCOORD3;
   	
   	float3 Nv					: TEXCOORD4;
   	float3 Ns					: TEXCOORD5;
   	float3 Nt					: TEXCOORD6;

   	float2 slide				: TEXCOORD7;

	float4 color				: COLOR;
	
	float fogDistance			: FOG;
};

struct PSInput
{
   	float3 vtViewDirection		: TEXCOORD0;
   	float2 uv0					: TEXCOORD1;
   	float2 uv1					: TEXCOORD2;
   	float2 uv2					: TEXCOORD3;

   	float3 Nv					: TEXCOORD4;
   	float3 Ns					: TEXCOORD5;
   	float3 Nt					: TEXCOORD6;

   	float2 slide				: TEXCOORD7;

	float4 color				: COLOR;

	float fogDistance			: FOG;
};

VSOutput VS(
	float3 iPosition	: POSITION,
	float3 iNormal		: NORMAL,
	float2 iTexCoord0	: TEXCOORD0,
	float2 iTexCoord1	: TEXCOORD3,
	float2 iTexCoord2	: TEXCOORD4,

	float4 iColor		: COLOR0,

	float3 iTangent		: TEXCOORD1,
	float3 iBinormal	: TEXCOORD2)
{
	VSOutput o;

	// ï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Cï¿½Yï¿½Ìˆ×‚É’ï¿½ï¿½_ï¿½Ì“ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½oï¿½ÍB
	o.vtPosition = mul(g_mtxWorldViewProj, float4(iPosition,1));

	// Viewï¿½ï¿½ï¿½Wï¿½nï¿½Å‚Ìƒsï¿½Nï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ç‹ï¿½_ï¿½Ö‚Ìƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½vï¿½Zï¿½B
	// PerPixelLightingï¿½É‚ï¿½ï¿½ï¿½ï¿½ÄQï¿½Æ‚ï¿½ï¿½ï¿½ï¿½B
//	if(g_mtxProjection[3][3] == 0.0f)
	{
		// ï¿½ï¿½ï¿½ï¿½ï¿½ÏŠï¿½ï¿½Ìê‡ï¿½Bï¿½ï¿½ï¿½ÊB
		o.vtViewDirection = -1.0f * mul(g_mtxWorldView, float4(iPosition,1)).xyz;
	}
//	else
//	{
//		// ï¿½ï¿½ï¿½Ë‰eï¿½sï¿½ï¿½Ìê‡ï¿½Aï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½ï¿½ï¿½ï¿½ç‚¸ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Í•ï¿½ï¿½sï¿½É‚È‚ï¿½B
//		o.vtViewDirection = float3(0,0,-1);
//	}

	if(g_enablesNormalMap || g_parallaxMapBiglandsEngine)
	{
		float3 tmpNs;
		float3 tmpNt;
		float3 tmpNv;
		if(g_enablesNormalMap && (g_normalMapType == 0))
		{
			// ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ìƒï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½Å‚Ì–@ï¿½ï¿½ï¿½}ï¿½bï¿½v
			// ï¿½@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½ÌŠï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½pï¿½ÉAï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ÌŠï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½
			// ï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Wï¿½nï¿½Ö•ÏŠï¿½ï¿½ï¿½ï¿½Äoï¿½ÍB
			tmpNs = g_vtBaseAxis[g_normalMapAxisR];
			tmpNt = g_vtBaseAxis[g_normalMapAxisG];
			tmpNv = cross(tmpNs, tmpNt);
			if(dot(g_vtBaseAxis[g_normalMapAxisB], tmpNv) < 0)
			{
				tmpNv *= -1.0f;
			}
		}
		else
		{
			// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ÌÚï¿½ï¿½ï¿½Ô‚Å‚Ì–@ï¿½ï¿½ï¿½}ï¿½bï¿½v
			// Mayaï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Í‚ï¿½ï¿½ï¿½ï¿½Tangentï¿½ï¿½Binormalï¿½Í‹tï¿½É‚È‚ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½Ì‚Å“ï¿½ï¿½ï¿½Ö‚ï¿½ï¿½ï¿½
			// r -> binormal
			// g -> tangent
			tmpNs = g_swapTangentAndBinormal? iBinormal: iTangent;
			// Mayaï¿½Å‚Íƒeï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½È‚Ì‚ÅABinormalï¿½ğ”½“]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
			tmpNt = g_swapTangentAndBinormal? -iTangent: -iBinormal;
			tmpNv = cross(iTangent, iBinormal);
			if(dot(iNormal, tmpNv) < 0)
			{
				tmpNv *= -1.0f;
			}
		}
		o.Ns = mul((float3x3)g_mtxWorldView, tmpNs);
		o.Nt = mul((float3x3)g_mtxWorldView, tmpNt);
		o.Nv = mul((float3x3)g_mtxWorldView, tmpNv);

		// ï¿½pï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½Xï¿½}ï¿½bï¿½vï¿½ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½
		float3 vtVDir = normalize(o.vtViewDirection);
		// Mayaï¿½Å‚Íƒeï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½È‚Ì‚ÅAslide.yï¿½ğ”½“]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
		o.slide = float2(dot(o.Ns, vtVDir), -dot(o.Nt, vtVDir));

		if(g_enablesNormalMap && (g_normalMapType == 1))
		{
			o.Ns *= g_flipTangent? -1.0f: 1.0f;
			o.Nt *= g_flipBinormal? -1.0f: 1.0f;
		}
	}
	else
	{
		// Viewï¿½ï¿½ï¿½Wï¿½nï¿½Å‚Ì–@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ÍB
		o.Nv = mul((float3x3)g_mtxWorldView, iNormal);
		// ï¿½@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½pï¿½ÌŠï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½Íoï¿½Í‚ï¿½ï¿½È‚ï¿½ï¿½B
		o.Ns = float3(0, 0, 0);
		o.Nt = float3(0, 0, 0);
		// ï¿½pï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½Xï¿½}ï¿½bï¿½vï¿½ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½
		o.slide = float2(0, 0);
	}

	// UVï¿½ï¿½ï¿½Wï¿½ÌŒvï¿½Z
	// ï¿½vï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½UVï¿½ï¿½ï¿½Wï¿½Aï¿½jï¿½ï¿½ï¿½[ï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½ÌŒï¿½ï¿½_ï¿½Íï¿½ï¿½ï¿½É‚È‚ï¿½B
	// Mayaï¿½Íï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½È‚Ì‚ï¿½Vï¿½ï¿½ï¿½ï¿½ï¿½ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½ğ”½“]ï¿½ï¿½ï¿½ï¿½ï¿½A
	// ï¿½Xï¿½Pï¿½[ï¿½ï¿½ï¿½sï¿½{ï¿½bï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Éİ’è‚·ï¿½ï¿½B
	float2 repeat1 = g_texcoordTransformRepeat1;
	float2 repeat2 = g_texcoordTransformRepeat2;
	float2 repeat3 = g_texcoordTransformRepeat3;
	float2 offset1 = float2( g_texcoordTransformOffset1.x, -g_texcoordTransformOffset1.y );
	float2 offset2 = float2( g_texcoordTransformOffset2.x, -g_texcoordTransformOffset2.y );
	float2 offset3 = float2( g_texcoordTransformOffset3.x, -g_texcoordTransformOffset3.y );

	o.uv0 =
		// TexTransform 0(ï¿½ï¿½ï¿½ï¿½)
		(step((float)g_baseColorTexTransform,0) * step(0,(float)g_baseColorTexTransform) *
			iTexCoord0)
		// TexTransform 1
	  + (step((float)g_baseColorTexTransform,1) * step(1,(float)g_baseColorTexTransform) *
			((((iTexCoord0-float2(0,1)) * repeat1)+float2(0,1)) + offset1))
		// TexTransform 2
	  + (step((float)g_baseColorTexTransform,2) * step(2,(float)g_baseColorTexTransform) *
			((((iTexCoord0-float2(0,1)) * repeat2)+float2(0,1)) + offset2))
		// TexTransform 3
	  + (step((float)g_baseColorTexTransform,3) * step(3,(float)g_baseColorTexTransform) *
			((((iTexCoord0-float2(0,1)) * repeat3)+float2(0,1)) + offset3));

	o.uv1 =
		// TexTransform 0(ï¿½ï¿½ï¿½ï¿½)
		(step((float)g_utilColorTexTransform,0) * step(0,(float)g_utilColorTexTransform) *
			iTexCoord1)
		// TexTransform 1
	  + (step((float)g_utilColorTexTransform,1) * step(1,(float)g_utilColorTexTransform) *
			((((iTexCoord1-float2(0,1)) * repeat1)+float2(0,1)) + offset1))
		// TexTransform 2
	  + (step((float)g_utilColorTexTransform,2) * step(2,(float)g_utilColorTexTransform) *
			((((iTexCoord1-float2(0,1)) * repeat2)+float2(0,1)) + offset2))
		// TexTransform 3
	  + (step((float)g_utilColorTexTransform,3) * step(3,(float)g_utilColorTexTransform) *
			((((iTexCoord1-float2(0,1)) * repeat3)+float2(0,1)) + offset3));

	o.uv2 =
		// TexTransform 0(ï¿½ï¿½ï¿½ï¿½)
		(step((float)g_normalMapTexTransform,0) * step(0,(float)g_normalMapTexTransform) *
			iTexCoord2)
		// TexTransform 1
	  + (step((float)g_normalMapTexTransform,1) * step(1,(float)g_normalMapTexTransform) *
			((((iTexCoord2-float2(0,1)) * repeat1)+float2(0,1)) + offset1))
		// TexTransform 2
	  + (step((float)g_normalMapTexTransform,2) * step(2,(float)g_normalMapTexTransform) *
			((((iTexCoord2-float2(0,1)) * repeat2)+float2(0,1)) + offset2))
		// TexTransform 3
	  + (step((float)g_normalMapTexTransform,3) * step(3,(float)g_normalMapTexTransform) *
			((((iTexCoord2-float2(0,1)) * repeat3)+float2(0,1)) + offset3));

	// ï¿½Jï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚Ü‚Üoï¿½ï¿½
	o.color = iColor;

	// ï¿½tï¿½Hï¿½Oï¿½Ì‹ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½oï¿½ï¿½
	// ï¿½ï¿½ï¿½`ï¿½tï¿½Hï¿½Oï¿½Å‚ÍAï¿½Jï¿½nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÌŠÔ‚Å‚Ìï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½Ï‚Ü‚ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½ï¿½B
	if(g_fogDensityType == 1)
	{
		o.fogDistance = (g_fogEnd - o.vtPosition.w) / (g_fogEnd - g_fogStart);
	}
	else
	{
		o.fogDistance = o.vtPosition.w;
	}

	return o;
}

float4 PS(
	PSInput i
	) : COLOR0
{
	// ï¿½ï¿½ï¿½ï¿½ï¿½Ì•ï¿½ï¿½ï¿½ï¿½ï¿½Viewï¿½ï¿½ï¿½Wï¿½nï¿½Ö•ÏŠï¿½ï¿½B
	float3 vtLightDir = -g_vtLightDir;
	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½ï¿½ï¿½ç‹ï¿½_ï¿½ÖŒï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì’Pï¿½Êƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½vï¿½Zï¿½B
	float3 vtEye = normalize(i.vtViewDirection);

	// ï¿½pï¿½ï¿½ï¿½ï¿½ï¿½bï¿½Nï¿½Xï¿½}ï¿½bï¿½vï¿½É‚ï¿½ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Aï¿½hï¿½ï¿½ï¿½Xï¿½ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½ï¿½vï¿½Z
	float2 uvBiglandsEngine = 0;
	if(g_enablesParallaxMap)
	{
		float height;
		if(g_parallaxMapSource == 0)
		{
			height = tex2D(g_texsmpBaseColor, i.uv0).a;
		}
		else if(g_parallaxMapSource == 1)
		{
			height = tex2D(g_texsmpUtilColor, i.uv1).a;
		}
		else
		{
			height = tex2D(g_texsmpNormalMap, i.uv2).a;
		}
		uvBiglandsEngine = (1.0f - height) * -g_parallaxMapBiglandsEngine * i.slide;
	}

	// ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	float3 vtNormal;
	if(!g_enablesNormalMap)
	{
		// ï¿½ï¿½ï¿½_ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½ï¿½ï¿½oï¿½Í‚ï¿½ï¿½ê‚½ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½ï¿½gï¿½ï¿½ï¿½B
		vtNormal = i.Nv;
	}
	else
	{
		// ï¿½@ï¿½ï¿½ï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ç‚İï¿½ï¿½B
		float3 n = tex2D(g_texsmpNormalMap, i.uv2+uvBiglandsEngine).xyz;
		n = 2.0f * (n - 0.5f);
		vtNormal = (n.x * i.Ns) + (n.y * i.Nt) + (n.z * i.Nv);
	}
	// ï¿½@ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ğ³‹Kï¿½ï¿½ï¿½B
	vtNormal = normalize(vtNormal);

	// ï¿½xï¿½[ï¿½Xï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½tï¿½Fï¿½bï¿½`
	float4 textureColor[2];
	textureColor[0] = g_enablesBaseColorTex? tex2D(g_texsmpBaseColor, i.uv0+uvBiglandsEngine): float4(1,1,1,1);
	textureColor[1] = g_enablesUtilColorTex? tex2D(g_texsmpUtilColor, i.uv1+uvBiglandsEngine): float4(1,1,1,1);

	// ï¿½|ï¿½ï¿½ï¿½Sï¿½ï¿½ï¿½Ìƒxï¿½[ï¿½Xï¿½Jï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	float4 colorMaterial;
	if(g_diffuseColorSelect == 0)
	{
		// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[
		float4 diffuse = g_diffuseColor;
		diffuse.a = 1.0f-g_transparency;
		colorMaterial = diffuse;
	}
	else if(g_diffuseColorSelect == 1)
	{
		// ï¿½ï¿½ï¿½_ï¿½Jï¿½ï¿½ï¿½[
		colorMaterial = i.color;
	}
	else
	{
		// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Æ’ï¿½ï¿½_ï¿½Jï¿½ï¿½ï¿½[ï¿½Ìï¿½
		float4 diffuse = g_diffuseColor;
		diffuse.a = 1.0f-g_transparency;
		colorMaterial = diffuse * i.color;
	}

	// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Ìƒxï¿½[ï¿½Xï¿½Jï¿½ï¿½ï¿½[ï¿½É‘Î‚ï¿½ï¿½éƒ‰ï¿½Cï¿½eï¿½Bï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½Ê‚Ì‹Pï¿½x
	float4 lumDiffuse = { 0, 0, 0, 1 };
	float3 lumSpecular = { 0, 0, 0 };
	float3 lumRimSpecular = { 0, 0, 0 };

	// ï¿½ï¿½ï¿½Cï¿½eï¿½Bï¿½ï¿½ï¿½O
	if(g_enablesLighting != false)
	{
		// ï¿½ï¿½ï¿½Fï¿½Ìƒ}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½É‘Î‚ï¿½ï¿½Ä‚ÌŠgï¿½Uï¿½ï¿½ï¿½Ë‚ï¿½ï¿½vï¿½Zï¿½B
		float d = max(0, dot(vtNormal, vtLightDir));
		lumDiffuse.rgb += d * g_colorLight.rgb;

		// ï¿½Â‹ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Z
		lumDiffuse.rgb += g_ambientLightColor;

		// ï¿½ï¿½ï¿½Fï¿½Ìƒ}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½É‘Î‚ï¿½ï¿½Ä‚ÌƒXï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½vï¿½Zï¿½B
		if(g_enablesSpecular)
		{
			float3 vtHalf = normalize(vtLightDir + vtEye);
			float s = max(0, dot(vtNormal, vtHalf));
			s = pow(s, g_SpecularPower);
			lumSpecular += s * g_colorLight.rgb;
		}

		// ï¿½ï¿½ï¿½Fï¿½Ìƒ}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½É‘Î‚ï¿½ï¿½Ä‚Ìƒï¿½ï¿½ï¿½ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½vï¿½Zï¿½B
		if(g_enablesRimSpecular)
		{
			float fr = pow((1.0f - dot(vtNormal, vtEye)), g_rimSpecularPower);
			float lumi = saturate(dot(vtNormal, vtLightDir) + g_rimSpecularSelfLuminous);
			lumRimSpecular = (fr * lumi) * g_colorLight.rgb;
		}

		// ï¿½gï¿½Uï¿½ï¿½ï¿½Ë‚ÌŒï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½pï¿½B
		lumDiffuse *= g_diffuseAttenuation;
		// ï¿½ï¿½ï¿½È”ï¿½ï¿½ï¿½ï¿½Ì‹Pï¿½xï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½B
		lumDiffuse.rgb += g_emissionColor;

		// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[ï¿½ÉŠgï¿½Uï¿½ï¿½ï¿½Ë‚ÌƒVï¿½Fï¿½[ï¿½fï¿½Bï¿½ï¿½ï¿½Oï¿½ï¿½Kï¿½pï¿½B
		colorMaterial.rgb *= lumDiffuse.rgb;
	}
	else
	{
		lumDiffuse = float4(1,1,1,1);
		lumSpecular = float3(0,0,0);
	}

	// ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[/ï¿½Aï¿½ï¿½ï¿½tï¿½@ï¿½ï¿½Kï¿½p
	// ï¿½sï¿½Nï¿½Zï¿½ï¿½ï¿½ÌÅIï¿½Jï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ïï¿½ï¿½B
	float4 pixelColor = colorMaterial;
	if(g_enablesBaseColorTex)
	{
		// ï¿½xï¿½[ï¿½Xï¿½Jï¿½ï¿½ï¿½[ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
		pixelColor =
			// ModulateRGBA
			(step((float)g_blendBaseColorTexture,0) * step(0,(float)g_blendBaseColorTexture) *
				pixelColor * textureColor[0])
			// ModulateRGB
		  + (step((float)g_blendBaseColorTexture,1) * step(1,(float)g_blendBaseColorTexture) *
				float4((pixelColor * textureColor[0]).rgb, pixelColor.a))
			// AddRGB
		  + (step((float)g_blendBaseColorTexture,2) * step(2,(float)g_blendBaseColorTexture) *
				float4((pixelColor + textureColor[0]).rgb, pixelColor.a))
			// DecalRGBA_Ma 
		  + (step((float)g_blendBaseColorTexture,3) * step(3,(float)g_blendBaseColorTexture) *
				float4(lerp(pixelColor, textureColor[0], pixelColor.a).rgb,
					   lerp(1, textureColor[0].a, pixelColor.a)))
			// DecalRGB_Ta 
		  + (step((float)g_blendBaseColorTexture,4) * step(4,(float)g_blendBaseColorTexture) *
				float4(lerp(pixelColor, textureColor[0], textureColor[0].a).rgb,
					   pixelColor.a))
			// ModulateDecalRGBA_Ma 
		  + (step((float)g_blendBaseColorTexture,5) * step(5,(float)g_blendBaseColorTexture) *
				float4(pixelColor * lerp(float4(1,1,1,1), textureColor[0], pixelColor.a).rgb,
					   lerp(1, textureColor[0].a, pixelColor.a)))
			// ModulateDecalRGB_Ta 
		  + (step((float)g_blendBaseColorTexture,6) * step(6,(float)g_blendBaseColorTexture) *
				float4(pixelColor.rgb * lerp(float4(1,1,1,1), textureColor[0], textureColor[0].a).rgb,
					   pixelColor.a));
	}
	if(g_enablesUtilColorTex)
	{
		// ï¿½â•ï¿½Jï¿½ï¿½ï¿½[ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½Ìï¿½ï¿½ï¿½
		pixelColor =
			// ModulateRGBA
			(step((float)g_blendUtilColorTexture,0) * step(0,(float)g_blendUtilColorTexture) *
				(pixelColor * textureColor[1]))
			// ModulateRGB
		  + (step((float)g_blendUtilColorTexture,1) * step(1,(float)g_blendUtilColorTexture) *
				float4((pixelColor * textureColor[1]).rgb, pixelColor.a))
		  // AddRGB
		  + (step((float)g_blendUtilColorTexture,2) * step(2,(float)g_blendUtilColorTexture) *
				float4((pixelColor + textureColor[1]).rgb, pixelColor.a))
		  // DecalRGB_Ma
		  + (step((float)g_blendUtilColorTexture,3) * step(3,(float)g_blendUtilColorTexture) *
				float4(lerp((colorMaterial*textureColor[0]), textureColor[1], colorMaterial.a).rgb,
					   1.0))
		  // DecalRGBA_Ma
		  + (step((float)g_blendUtilColorTexture,4) * step(4,(float)g_blendUtilColorTexture) *
				float4(lerp((colorMaterial*textureColor[0]), textureColor[1], colorMaterial.a).rgb,
					   lerp(textureColor[0].a, textureColor[1].a, colorMaterial.a)))
		  // DecalRGBA_Ta
		  + (step((float)g_blendUtilColorTexture,5) * step(5,(float)g_blendUtilColorTexture) *
				float4(lerp((colorMaterial*textureColor[0]), textureColor[1], colorMaterial.a).rgb,
					   lerp(colorMaterial.a*textureColor[0].a, colorMaterial.a, textureColor[1].a)))
		  // ModulateDecalRGB_Ma
		  + (step((float)g_blendUtilColorTexture,6) * step(6,(float)g_blendUtilColorTexture) *
				float4((colorMaterial * lerp(textureColor[0], textureColor[1], colorMaterial.a)).rgb,
					   1.0))
		  // ModulateDecalRGBA_Ma
		  + (step((float)g_blendUtilColorTexture,7) * step(7,(float)g_blendUtilColorTexture) *
				float4((colorMaterial * lerp(textureColor[0], textureColor[1], colorMaterial.a)).rgb,
					   lerp(textureColor[0].a, textureColor[1].a, colorMaterial.a)))
		  // ModulateDecalRGBA_Ta
		  + (step((float)g_blendUtilColorTexture,8) * step(8,(float)g_blendUtilColorTexture) *
				float4((colorMaterial * lerp(textureColor[0], textureColor[1], textureColor[1].a)).rgb,
					   colorMaterial.a * lerp(textureColor[0].a, 1.0, textureColor[1].a)));
	}

	// ï¿½Oï¿½ï¿½ï¿½Xï¿½}ï¿½bï¿½vï¿½lï¿½ï¿½ï¿½ï¿½
	float glossMap;
	if(!g_enablesGlossMap)
	{
		// ï¿½ï¿½ï¿½ï¿½
		glossMap = 1.0f;
	}
	else if(g_indexGlossSrc == 0)
	{
		// ï¿½xï¿½[ï¿½Xï¿½Jï¿½ï¿½ï¿½[ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½B
		glossMap = textureColor[0].a;
	}
	else if(g_indexGlossSrc == 1)
	{
		// ï¿½â•ï¿½Jï¿½ï¿½ï¿½[ï¿½eï¿½Nï¿½Xï¿½`ï¿½ï¿½ï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½B
		glossMap = textureColor[1].a;
	}
	else
	{
		// ï¿½tï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½gï¿½ÌƒAï¿½ï¿½ï¿½tï¿½@ï¿½B
		glossMap = pixelColor.a;
	}

	// ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½Jï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	float3 colorSpecular;
	if(g_specularColorSelector == 0)
	{
		// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[
		colorSpecular = g_colorSpecular;
	}
	else if(g_specularColorSelector == 1)
	{
		// ï¿½ï¿½ï¿½_ï¿½Jï¿½ï¿½ï¿½[
		colorSpecular = i.color.rgb;
	}
	else if(g_specularColorSelector == 2)
	{
		// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Æ’ï¿½ï¿½_ï¿½Jï¿½ï¿½ï¿½[ï¿½Ìï¿½
		colorSpecular = g_colorSpecular * i.color.rgb;
	}
	else
	{
		// ï¿½tï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½gï¿½ÌƒJï¿½ï¿½ï¿½[ï¿½B
		colorSpecular = g_colorSpecular * pixelColor.rgb;
	}

	// ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½ï¿½ï¿½B
	pixelColor.rgb += glossMap * lumSpecular * colorSpecular;

	// ï¿½ï¿½ï¿½ï¿½ï¿½Xï¿½yï¿½Lï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Ì‚ï¿½ï¿½ï¿½B
	if(g_enablesRimSpecular)
	{
		float3 colorRimSpecular;
		if(g_specularColorSelector == 0)
		{
			// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[
			colorRimSpecular = g_colorRimSpecular;
		}
		else if(g_specularColorSelector == 1)
		{
			// ï¿½ï¿½ï¿½_ï¿½Jï¿½ï¿½ï¿½[
			colorRimSpecular = i.color.rgb;
		}
		else if(g_specularColorSelector == 2)
		{
			// ï¿½}ï¿½eï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½Æ’ï¿½ï¿½_ï¿½Jï¿½ï¿½ï¿½[ï¿½Ìï¿½
			colorRimSpecular = g_colorRimSpecular * i.color.rgb;
		}
		else
		{
			// ï¿½tï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½ï¿½gï¿½ÌƒJï¿½ï¿½ï¿½[ï¿½B
			colorRimSpecular = g_colorRimSpecular * pixelColor.rgb;
		}

		pixelColor.rgb += glossMap * lumRimSpecular * colorRimSpecular;
	}

	// ï¿½Â‹ï¿½ï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½Ì‚ï¿½ï¿½ï¿½
	if(g_enablesEnvironmentMap)
	{
		float4 colEnvironmentMap = { 0, 0, 0, 0 };
		// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Wï¿½nï¿½Å‚ÌƒLï¿½ï¿½ï¿½[ï¿½uï¿½Â‹ï¿½ï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½sï¿½ï¿½ï¿½B
		float3 rv = normalize((float3)reflect(vtEye, vtNormal));
		if(g_environmentMapType == 0)
		{
			// ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½Wï¿½nï¿½Å‚ÌƒLï¿½ï¿½ï¿½[ï¿½uï¿½Â‹ï¿½ï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½sï¿½ï¿½ï¿½B
			rv = mul(g_imtxView, float4(rv,0)).xyz;
			// Mayaï¿½ï¿½Direct3Dï¿½Ìï¿½ï¿½Wï¿½nï¿½Ìˆá‚¢ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½B
			rv = float3(-1,-1, 1) * rv.xyz;
	
			colEnvironmentMap =
				g_colorEnvironmentMapModulate
			  * texCUBE(g_texsmpCubeEnvironmentMap, rv);
		}
		else
		{
			// ï¿½ï¿½ï¿½Ê”ï¿½ï¿½ËŠÂ‹ï¿½ï¿½}ï¿½bï¿½v(g_environmentMapType == 2)ï¿½ï¿½ï¿½wï¿½è‚³ï¿½ê‚½ï¿½Æ‚ï¿½ï¿½ï¿½
			// ï¿½vï¿½ï¿½ï¿½rï¿½ï¿½ï¿½[ï¿½Vï¿½Fï¿½[ï¿½_ï¿½ï¿½Å‚Í‹ï¿½ï¿½ÊŠÂ‹ï¿½ï¿½}ï¿½bï¿½vï¿½Æ‚ï¿½ï¿½Ä•\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½B

			// ï¿½rï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Wï¿½nï¿½Å‚Ì‹ï¿½ï¿½ï¿½Â‹ï¿½ï¿½}ï¿½bï¿½vï¿½ï¿½ï¿½sï¿½ï¿½
			float3 r = rv;
			r.z -= 1.0;
			r = r * r;
			float m = rsqrt(r.x + r.y + r.z);
			float2 uv = float2(0.5,-0.5) * (rv.xy * m + float2(1.0, 1.0));

			colEnvironmentMap =
				g_colorEnvironmentMapModulate
			  * tex2D(g_texsmpSphericalEnvironmentMap, uv);
		}

		if(g_enablesFresnelTerm)
		{
			// ï¿½tï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½É‚ï¿½ï¿½ï¿½ÄŠÂ‹ï¿½ï¿½}ï¿½bï¿½vï¿½Ì‹ï¿½ï¿½ï¿½ï¿½ğ’²ï¿½ï¿½ï¿½ï¿½ï¿½B
			float f = pow(1.0f - dot(vtEye, vtNormal), 4.0f);
			f = g_fresnelR0 + g_fresnelR1 * f;
			f *= glossMap;
			pixelColor.rgb = lerp(pixelColor.rgb, colEnvironmentMap.rgb, f);
		}
		else
		{
			// ï¿½ï¿½ï¿½Ì‚Ü‚Üƒsï¿½Nï¿½Zï¿½ï¿½ï¿½ÌFï¿½Ö‰ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½B
			pixelColor.rgb += glossMap * colEnvironmentMap.rgb;
		}
	}

	// ï¿½tï¿½Hï¿½Oï¿½Æ‚Ìï¿½ï¿½ï¿½
	//  ï¿½tï¿½Hï¿½Oï¿½Xï¿½Cï¿½bï¿½`ï¿½ï¿½OFFï¿½È‚ï¿½Îƒtï¿½Hï¿½Oï¿½ğ–³Œï¿½ï¿½É‚ï¿½ï¿½ï¿½B
	int fogType = (g_enablesFog? 1: 0) * g_fogDensityType;
	if(fogType == 0)
	{
		// ï¿½tï¿½Hï¿½Oï¿½ï¿½ï¿½ï¿½
	}
	else if(fogType == 1)
	{
		// ï¿½ï¿½ï¿½`ï¿½tï¿½Hï¿½O
		pixelColor.rgb = lerp(
			g_fogColor.rgb,
			pixelColor.rgb,
			clamp(i.fogDistance, 0, 1));
	}
	else if(fogType == 2)
	{
		// ï¿½wï¿½ï¿½ï¿½tï¿½Hï¿½O
		float d = ((g_fogDensity * 0.001) * i.fogDistance);
		pixelColor.rgb = lerp(
			g_fogColor.rgb,
			pixelColor.rgb,
			exp(-d));
	}
	else if(fogType == 3)
	{
		// ï¿½wï¿½ï¿½ï¿½tï¿½Hï¿½O2
		float d = ((g_fogDensity * 0.001) * i.fogDistance);
		pixelColor.rgb = lerp(
			g_fogColor.rgb,
			pixelColor.rgb,
			exp(-d*d));
	}

	// ï¿½fï¿½oï¿½bï¿½Oï¿½Ú“Iï¿½ÅAï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½[ï¿½Åoï¿½ÍB
	if(g_debugShowNormalDir)
	{
		pixelColor.rgb = float3(vtNormal);
	}
	return pixelColor;
}

technique OPACITY
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();

		DepthTestEnable		= true;
		DepthMask			= true;
		
		BlendEnable			= false;
		AlphaTestEnable		= false;
    }
}

technique ALPHATEST
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= true;

		BlendEnable			= false;
		BlendFunc			= int2(SrcAlpha, OneMinusSrcAlpha);

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0.49f);
    }
}

technique BLEND
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= false;

		BlendEnable			= true;
		BlendFunc			= int2(SrcAlpha, OneMinusSrcAlpha);
		BlendEquation		= Add;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}

technique BLEND_2PASS
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();
		FragmentProgram	= compile fp30 PS();

		DepthTestEnable		= true;
		DepthMask			= false;
		
		BlendEnable			= true;
		BlendFunc			= int2(SrcAlpha, OneMinusSrcAlpha);
		BlendEquation		= Add;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}

technique ADD
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= false;

		BlendEnable			= true;
		BlendFunc			= int2(SrcAlpha, One);
		BlendEquation		= Add;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}

technique SUB
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= false;

		BlendEnable			= true;
		BlendFunc			= int2(SrcAlpha, One);
		BlendEquation		= ReverseSubtract;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}

technique MODULATE
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= false;

		BlendEnable			= true;
		BlendFunc			= int2(DestColor, Zero);
		BlendEquation		= Add;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}

technique CUSTOM
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= false;

		BlendEnable			= true;
		BlendFunc			= int2(SrcAlpha, OneMinusSrcAlpha);
		BlendEquation		= Add;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}

technique SPECULAR_2PASS
{
    pass P0 
    {		
       	PolygonMode			= int2(FrontAndBack, Fill); 

		VertexProgram	= compile vp30 VS();

		FragmentProgram	= compile fp30 PS();
		
		DepthTestEnable		= true;
		DepthMask			= false;

		BlendEnable			= true;
		BlendFunc			= int2(SrcAlpha, OneMinusSrcAlpha);
		BlendEquation		= Add;

		AlphaTestEnable		= true;
		AlphaFunc			= float2(Greater, 0);
    }
}



